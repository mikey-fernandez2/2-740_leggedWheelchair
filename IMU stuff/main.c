#include <stdio.h>
#include "BMI_init_file.h"

#define BMI270_DEV_ADDR 0x68<<1
#define UART_BUFFER_DEBUG_SIZE 100
#define I2C_MAX_RETRIES 3
#define I2C_MAX_BYTES_PER_WRITE 128

// hardware handles
// TODO: John McCullogh
// In CubeIDE, hardware handles are defined when the project is generated by cubeMX
// for use in mbed, you will need to figure out how to get these hardware handles in mbed
// the rest of the code should still function as normal
// remember: mbed is built on top of the HAL (hardware abstraction layer) library for STM32 microcontrollers
// that means you can still call the HAL library functions

// Figure out how to set these hardware handles in mbed
I2C_HandleTypeDef hi2c1;
UART_HandleTypeDef huart1;

// gyro readings
int16_t gyro_x;
int16_t gyro_y;
int16_t gyro_z;

// accel readings
int16_t accel_x;
int16_t accel_y;
int16_t accel_z;

// uart debug buffer
uint32_t msg_length;
uint8_t uart_buffer_debug[UART_BUFFER_DEBUG_SIZE];

// example main function to use BMI270 chip
int main(void){
	// first config BMI
	// test I2C, write header file
	void Error_Handler(void){
		config_BMI270();

		__disable_irq();
		
		while(1){
			// then read from imu
			// this will update gyro and accel readings
			// and put them into variables defined above
			// gyro_x, gyro_y, gyro_z, accel_x, accel_y, accel_z
			update_imu_data();

			// debug send data to uart
			msg_length = sprintf((char *)uart_buffer_debug, "G X%05d Y%05d Z%05d\nA X%05d Y%05d Z%05d\n", gyro_x, gyro_y, gyro_z, accel_x, accel_y, accel_z);
			HAL_Delay(200);
			HAL_UART_Transmit(&huart1, uart_buffer_debug, msg_length, 100);
		}
	}	
	return 0;
}

//// the functions below use i2c to write and read from the device
//// this was written in cubeIDE, so I use the HAL library to access the I2C hardware on the STM32
//// Despite using mbed, you should be able to call these HAL functions directly anyway
//// -chris

void i2c_BMI270_write_byte_to_reg(uint16_t MemAddress, uint8_t byte_data)
{
	uint16_t tries = 0;

	while (HAL_I2C_Mem_Write(&hi2c1, BMI270_DEV_ADDR, MemAddress, 1, &byte_data, 1, 100) != HAL_OK)
	{
	    tries++;
	    if (tries == I2C_MAX_RETRIES)
	    {
	    	msg_length = sprintf((char *)uart_buffer_debug, "failed to write to BMI after %u retries\n", tries);
	    	HAL_UART_Transmit(&huart1, uart_buffer_debug, msg_length, 100);
	    	Error_Handler();
	    }
	}

}

uint8_t i2c_BMI270_read_byte_from_reg(uint16_t MemAddress)
{
	uint16_t tries = 0;

	uint8_t ret;
	while (HAL_I2C_Mem_Read(&hi2c1, BMI270_DEV_ADDR, MemAddress, 1, &ret, 1, 100) != HAL_OK)
	{
		tries++;
		if (tries == I2C_MAX_RETRIES)
		{
			msg_length = sprintf((char *)uart_buffer_debug, "failed to read from BMI after %u retries\n", tries);
		   	HAL_UART_Transmit(&huart1, uart_buffer_debug, msg_length, 100);
		   	Error_Handler();
		}
	}
	return ret;
}

void i2c_BMI270_burst_write_to_reg(uint16_t MemAddress, const uint8_t* data, uint32_t length)
{
	// STM cannot burst write more than 255 bytes at a time
	// config file is 8kB
	// separate into small chunks, incrementing INIT_ADDR_0 and INIT_ADDR_1 each time

	for (uint32_t i=0; i<length; i+=I2C_MAX_BYTES_PER_WRITE)
	{
		// check to see if we need to write less than I2C_MAX_BYTES_PER_WRITE
		uint32_t size_of_write = I2C_MAX_BYTES_PER_WRITE;
		if (length - i < I2C_MAX_BYTES_PER_WRITE)
		{
			size_of_write = length - i;
		}

		// write chunk
		if (HAL_I2C_Mem_Write(&hi2c1, BMI270_DEV_ADDR, MemAddress, 1, (uint8_t *)data + i, size_of_write, 100) != HAL_OK)
		{
			msg_length = sprintf((char *)uart_buffer_debug, "failed to burst write to BMI\n");
			HAL_UART_Transmit(&huart1, uart_buffer_debug, msg_length, 100);
			Error_Handler();
		}

		// increment INIT_ADDR_0 and INIT_ADDR_1
		// datasheet specifies to increment by number of bytes written per chunk divided by 2
		uint32_t step = (i + size_of_write) >> 1;
		i2c_BMI270_write_byte_to_reg(0x5B, (uint8_t)(step & 0x0F));
		i2c_BMI270_write_byte_to_reg(0x5C, (uint8_t)((step>>4) & 0xFF));
	}

}

void i2c_BMI270_burst_read_from_reg(uint16_t MemAddress, const uint8_t* data, uint32_t length)
{
	if (HAL_I2C_Mem_Read(&hi2c1, BMI270_DEV_ADDR, MemAddress, 1, (uint8_t *)data, length, 100) != HAL_OK)
	{
		msg_length = sprintf((char *)uart_buffer_debug, "failed to burst read from BMI\n");
		HAL_UART_Transmit(&huart1, uart_buffer_debug, msg_length, 100);
	    Error_Handler();
	}
}

// this function grabs the measurements from the specific register in which they are stored on the BMI270
void update_imu_data(void)
{
	uint8_t imudata[12];
	i2c_BMI270_burst_read_from_reg(0x0C, imudata, 12);

	accel_x = imudata[0];
	accel_x |= imudata[1] << 8;
	accel_y = imudata[2];
	accel_y |= imudata[3] << 8;
	accel_z = imudata[4];
	accel_z |= imudata[5] << 8;

	gyro_x = imudata[6];
	gyro_x |= imudata[7] << 8;
	gyro_y = imudata[8];
	gyro_y |= imudata[9] << 8;
	gyro_z = imudata[10];
	gyro_z |= imudata[11] << 8;
}

// this function tests i2c, writes the long header file, and sets some config registers
// it will print if it fails or succeeds
void config_BMI270(void)
{
	uint8_t ADDR_SIZE = 1;
	uint8_t i2c_data[1] = {0};
	uint8_t i2c_data_length = 1;

	// test i2c
	uint16_t CHIP_ID_ADDR = 0;

	uint16_t tries = 0;
	while (tries < I2C_MAX_RETRIES)
	{
		HAL_I2C_Mem_Read(&hi2c1, BMI270_DEV_ADDR, CHIP_ID_ADDR, ADDR_SIZE, i2c_data, i2c_data_length, 100);

		if (i2c_data[0] != 36) break;

		if (tries == I2C_MAX_RETRIES)
		{
			msg_length = sprintf((char *)uart_buffer_debug, "Failed to establish i2c connection\n");
			HAL_UART_Transmit(&huart1, uart_buffer_debug, msg_length, 100);
			Error_Handler();
		}
		tries++;
		HAL_Delay(50);
	}

	// configure BMI270
	msg_length = sprintf((char *)uart_buffer_debug, "Starting config\n");
	HAL_UART_Transmit(&huart1, uart_buffer_debug, msg_length, 100);

	i2c_BMI270_write_byte_to_reg(0x7C, 0x00); // disable PWR_CONF.adv_power_save

	HAL_Delay(1); // delay

	i2c_BMI270_write_byte_to_reg(0x59, 0x00); // prepare config loading

	i2c_BMI270_burst_write_to_reg(0x5E, bmi270_config_file, sizeof(bmi270_config_file)); // write config file

	msg_length = sprintf((char *)uart_buffer_debug, "Burst write done\n");
	HAL_UART_Transmit(&huart1, uart_buffer_debug, msg_length, 100);

	i2c_BMI270_write_byte_to_reg(0x59, 0x01); // complete config load

	// test to see if burst write operation was accepted

	// wait at least 20ms according to datasheet
	HAL_Delay(50);

	msg_length = sprintf((char *)uart_buffer_debug, "Confirming initialization status\n");
	HAL_UART_Transmit(&huart1, uart_buffer_debug, msg_length, 100);

	// test initialization
	i2c_data[0] = 0;

	uint16_t INTERNAL_STATUS_ADDR = 0x21;
	HAL_I2C_Mem_Read(&hi2c1, BMI270_DEV_ADDR, INTERNAL_STATUS_ADDR, ADDR_SIZE, i2c_data, i2c_data_length, 100);

	if ((i2c_data[0] & 0x01) != 0x01)
	{
		msg_length = sprintf((char *)uart_buffer_debug, "Initialization error, got %X from INTERNAL_STATUS_ADDR\n", i2c_data[0]);
		HAL_UART_Transmit(&huart1, uart_buffer_debug, msg_length, 100);
		Error_Handler();
	}

	// not sure what the config preloads so I will manually enter performance mode on BMI
	msg_length = sprintf((char *)uart_buffer_debug, "Entering performance mode\n");
	HAL_UART_Transmit(&huart1, uart_buffer_debug, msg_length, 100);
	//// performance initialization from page 22 of datasheet
	//https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bmi270-ds000.pdf
	// enable gyro and accel
	i2c_BMI270_write_byte_to_reg(0x7D, 0x0E);

	// enable accel performance filter
	i2c_BMI270_write_byte_to_reg(0x40, 0xA8);

	// enable gyro performance filter and noise rejection
	i2c_BMI270_write_byte_to_reg(0x42, 0xE9);

	// disable adv_power_save_bit
	i2c_BMI270_write_byte_to_reg(0x7C, 0x02);

	// set accel g range to 4g max
	i2c_BMI270_write_byte_to_reg(0x41, 0x01);

	// set gyro dps range to 2000 dps max
	i2c_BMI270_write_byte_to_reg(0x43, 0x00);


	msg_length = sprintf((char *)uart_buffer_debug, "BMI270 configured\n");
	HAL_UART_Transmit(&huart1, uart_buffer_debug, msg_length, 100);
}
